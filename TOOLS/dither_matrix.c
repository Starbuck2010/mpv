#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#define SIZEB 8
#define SIZE (1 << SIZEB)
#define SIZE2 (SIZE * SIZE)

#define X(c) ((c) & (SIZE - 1))
#define Y(c) ((c) >> SIZEB)
#define XY(x, y) ((index_t)(((x) | ((y) << SIZEB))))

#define GAUSS_RADIUS (SIZE / 2 - 1)
//#define GAUSS_RADIUS 10
#define GAUSS_SIZE (GAUSS_RADIUS + 1 + GAUSS_RADIUS)
#define GAUSS_SIZE2 (GAUSS_SIZE * GAUSS_SIZE)

static uint64_t gauss[GAUSS_SIZE2];

typedef uint32_t index_t;
#define INDEX_WRAP(x) ((index_t)((index_t)(x) & (SIZE - 1)))

static index_t randomat[SIZE2];
static bool calcmat[SIZE2];
static uint64_t gaussmat[SIZE2];
static index_t unimat[SIZE2];

static void makegauss(void) {
	long double sigma = -logl(1.5 / (long double)UINT64_MAX * (long double)GAUSS_SIZE2) / (long double)GAUSS_RADIUS;
//	fprintf(stderr, "sigma = %.20Lf\n", sigma);
	for(index_t gy = 0; gy <= GAUSS_RADIUS; gy++) {
		for(index_t gx = 0; gx <= gy; gx++) {
			int cx = (int)gx - GAUSS_RADIUS;
			int cy = (int)gy - GAUSS_RADIUS;
			int sq = cx*cx + cy*cy;
			long double e = expl(- sqrtl(sq) * sigma);
			uint64_t v = (uint64_t)(e / (long double)GAUSS_SIZE2 * (long double)UINT64_MAX);
			gauss[gx + gy * GAUSS_SIZE] =
			gauss[gy + gx * GAUSS_SIZE] =
			gauss[gx + (GAUSS_SIZE - 1 - gy) * GAUSS_SIZE] =
			gauss[gy + (GAUSS_SIZE - 1 - gx) * GAUSS_SIZE] =
			gauss[(GAUSS_SIZE - 1 - gx) + gy * GAUSS_SIZE] =
			gauss[(GAUSS_SIZE - 1 - gy) + gx * GAUSS_SIZE] =
			gauss[(GAUSS_SIZE - 1 - gx) + (GAUSS_SIZE - 1 - gy) * GAUSS_SIZE] =
			gauss[(GAUSS_SIZE - 1 - gy) + (GAUSS_SIZE - 1 - gx) * GAUSS_SIZE] = v;
		}
	}
	uint64_t total = 0;
	for(index_t c = 0; c < GAUSS_SIZE2; c++) {
		uint64_t oldtotal = total;
		total += gauss[c];
		assert(total >= oldtotal);
	}
/*
	for(index_t gy = 0; gy < GAUSS_SIZE; gy++) {
		for(index_t gx = 0; gx < GAUSS_SIZE; gx++)
//			fprintf(stderr, "%.20Lf ", (long double)gauss[gx + gy * GAUSS_SIZE] / (long double)UINT64_MAX);
			fprintf(stderr, "%"PRIu64" ", gauss[gx + gy * GAUSS_SIZE]);
		fprintf(stderr, "\n");
	}
*/
}

static void setbit(index_t c, bool v) {
	if(calcmat[c] == v)
		return;
	calcmat[c] = v;
	index_t x = X(c);
	index_t y = Y(c);
	for(index_t gy = 0; gy < GAUSS_SIZE; gy++) {
		for(index_t gx = 0; gx < GAUSS_SIZE; gx++) {
			index_t ox = INDEX_WRAP(x + gx - GAUSS_RADIUS);
			index_t oy = INDEX_WRAP(y + gy - GAUSS_RADIUS);
			index_t gc = XY(ox, oy);
			if(v)
				gaussmat[gc] += gauss[gx + gy * GAUSS_SIZE];
			else
				gaussmat[gc] -= gauss[gx + gy * GAUSS_SIZE];
		}
	}
}

static index_t getmin(void) {
	uint64_t min = UINT64_MAX;
	index_t resnum = 0;
	for(index_t c = 0; c < SIZE2; c++) {
		if(calcmat[c])
			continue;
		uint64_t total = gaussmat[c];
		if(total <= min) {
			if(total != min) {
				min = total;
				resnum = 0;
			}
			randomat[resnum++] = c;
		}
	}
	return randomat[random() % resnum];
}

static void makeuniform(void) {
	for(index_t c = 0; c < SIZE2; c++) {
		index_t r = getmin();
		setbit(r, true);
		unimat[r] = c;
	}
}

static void print(void) {
	puts("// Generated by TOOLS/dither_matrix.c");
	puts("#include <stdint.h>");
	printf("static const int mp_dither_size = %d;\n", SIZE);
	printf("static const int mp_dither_size2 = %d;\n", SIZE2);
	printf("static const uint16_t mp_dither_matrix[] = {\n");
	for(index_t y = 0; y < SIZE; y++) {
		printf("\t");
		for(index_t x = 0; x < SIZE; x++)
			printf("%4d, ", unimat[XY(x, y)]);
		printf("\n");
	}
	puts("};");
}

static int index_cmp(const void *a, const void *b) {
	index_t x = *(const index_t *)a;
	index_t y = *(const index_t *)b;
	return x < y ? -1 : x > y;
}

static void fsck(void) {
	qsort(unimat, SIZE2, sizeof *unimat, index_cmp);
	for(index_t c = 0; c < SIZE2; c++) {
		if(unimat[c] != c) {
			fprintf(stderr, "Result not correct :(\n");
			exit(2);
		}
	}
}

int main(void) {
	makegauss();
	makeuniform();
	print();
	fsck();
	return 0;
}
